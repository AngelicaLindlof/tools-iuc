<tool id="pp.pca" name="pp.pca" version="1.3.1+galaxy1">
  <description>Principal component analysis [Pedregosa11]_.</description>
  <macros>
    <import>macros.xml</import>
  </macros>
  <expand macro="requirements"/>
  <command detect_errors="exit_code"><![CDATA[
        python $script_file
    ]]></command>
  <configfiles>
    <configfile name="script_file"><![CDATA[
import scanpy.api as sc

@CMD_read_inputs

sc.pp.pca(
   data = '$adata',
   n_comps = '$n_comps',
   zero_center = '$zero_center',
   svd_solver = '$svd_solver',
   random_state = '$random_state',
   return_info = '$return_info',
   dtype = '$dtype',
   copy = '$copy',
   chunked = '$chunked',
   chunk_size = '$chunk_size',)

adata.write_loom($csv_output)
adata.write_csv($loom_output)
]]></configfile>
  </configfiles>
  <inputs>
    <expand macro="inputs_anndata"/>
    <param name="n_comps" type="int" value="" optional="true" label="n_comps" help="    Number of principal components to compute."/>
    <param name="zero_center" type="bool" value="True" optional="true" label="zero_center" help="    If `True`, compute standard PCA from covariance matrix. If `False`, omit    zero-centering variables (uses *TruncatedSVD* from scikit-learn), which    allows to handle sparse input efficiently."/>
    <param name="svd_solver" type="str" value="" optional="true" label="svd_solver" help="    SVD solver to use. Either 'arpack' for the ARPACK wrapper in SciPy    (scipy.sparse.linalg.svds), or 'randomized' for the randomized algorithm    due to Halko (2009). 'auto' chooses automatically depending on the size    of the problem."/>
    <param name="random_state" type="int" value="" optional="true" label="random_state" help="    Change to use different intial states for the optimization."/>
    <param name="return_info" type="bool" value="False" optional="true" label="return_info" help="    Only relevant when not passing an :class:`~anndata.AnnData`: see    &quot;Returns&quot;."/>
    <param name="dtype" type="str" value="" label="dtype" help="    Numpy data type string to which to convert the result."/>
    <param name="copy" type="bool" value="False" optional="true" label="copy" help="    If an :class:`~anndata.AnnData` is passed, determines whether a copy    is returned. Is ignored otherwise."/>
    <param name="chunked" type="bool" value="False" optional="true" label="chunked" help="    If `True`, perform an incremental PCA on segments of `chunk_size`. The    incremental PCA automatically zero centers and ignores settings of    `random_seed` and `svd_solver`. If `False`, perform a full PCA."/>
    <param name="chunk_size" type="int" value="None" optional="true" label="chunk_size" help="    Number of observations to include in each chunk. Required if `chunked`    is `True`."/>
    </inputs>
  <outputs>
    <data name="csv_output" type="data" format="csv" label="${tool.name} on ${on_string}: Annotated matrix (csv)"/>
    <data name="X_pca" type=".obsm" label="${tool.name} on ${on_string}: X_pca"/>
    <data name="PCs" type=".varm" label="${tool.name} on ${on_string}: PCs"/>
    <data name="variance_ratio" type=".uns['pca']" label="${tool.name} on ${on_string}: variance_ratio"/>
    <data name="variance" type=".uns['pca']" label="${tool.name} on ${on_string}: variance"/>
    <data name="loom_output" type="data" format="loom" label="${tool.name} on ${on_string}: Annotated matrix (loom)"/>
    </outputs>
  <tests>
    <test>
      <param name="n_comps" value=""/>
      <param name="zero_center" value=""/>
      <param name="svd_solver" value=""/>
      <param name="random_state" value=""/>
      <param name="return_info" value=""/>
      <param name="dtype" value=""/>
      <param name="copy" value=""/>
      <param name="chunked" value=""/>
      <param name="chunk_size" value=""/>
      <output name="loom_output" file=""/>
      <output name="csv_output" file=""/>
      <output name="X_pca" file=""/>
      <output name="PCs" file=""/>
      <output name="variance_ratio" file=""/>
      <output name="variance" file=""/>
      <output name="loom_output" file=""/>
    </test>
  </tests>
  <help><![CDATA[
        Principal component analysis [Pedregosa11]_.

Computes PCA coordinates, loadings and variance decomposition. Uses the
implementation of *scikit-learn* [Pedregosa11]_.

Parameters
----------
data : :class:`~anndata.AnnData`, `np.ndarray`, `sp.sparse`
    The (annotated) data matrix of shape `n_obs` Ã— `n_vars`. Rows correspond
    to cells and columns to genes.
n_comps : `int`, optional (default: 50)
    Number of principal components to compute.
zero_center : `bool` or `None`, optional (default: `True`)
    If `True`, compute standard PCA from covariance matrix. If `False`, omit
    zero-centering variables (uses *TruncatedSVD* from scikit-learn), which
    allows to handle sparse input efficiently.
svd_solver : `str`, optional (default: 'auto')
    SVD solver to use. Either 'arpack' for the ARPACK wrapper in SciPy
    (scipy.sparse.linalg.svds), or 'randomized' for the randomized algorithm
    due to Halko (2009). 'auto' chooses automatically depending on the size
    of the problem.
random_state : `int`, optional (default: 0)
    Change to use different intial states for the optimization.
return_info : `bool`, optional (default: `False`)
    Only relevant when not passing an :class:`~anndata.AnnData`: see
    "Returns".
dtype : `str` (default: 'float32')
    Numpy data type string to which to convert the result.
copy : `bool`, optional (default: `False`)
    If an :class:`~anndata.AnnData` is passed, determines whether a copy
    is returned. Is ignored otherwise.
chunked : `bool`, optional (default: `False`)
    If `True`, perform an incremental PCA on segments of `chunk_size`. The 
    incremental PCA automatically zero centers and ignores settings of 
    `random_seed` and `svd_solver`. If `False`, perform a full PCA.
chunk_size : `int`, optional (default: `None`)
    Number of observations to include in each chunk. Required if `chunked`
    is `True`.

Returns
-------
If `data` is array-like and `return_info == False`, only returns `X_pca`,    otherwise returns or adds to `adata`:
X_pca : `.obsm`
     PCA representation of data.
PCs : `.varm`
     The principal components containing the loadings.
variance_ratio : `.uns['pca']`
     Ratio of explained variance.
variance : `.uns['pca']`
     Explained variance, equivalent to the eigenvalues of the covariance matrix.
    ]]></help>
  <expand macro="citations"/>
</tool>
