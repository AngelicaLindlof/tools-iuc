<tool id="tl.rank_genes_groups" name="tl.rank_genes_groups" version="1.3.1+galaxy1">
    <description>Rank genes for characterizing groups</description>
    <macros>
        <import>macros.xml</import>
        <xml name="penalty">
            <param argument="penalty" type="select" label="Norm used in the penalization" help="">
                <option value="l1">l1</option>
                <option value="l2">l2</option>
                <option value="customized">customized</option>
            </param>
        </xml>
        <xml name="custom_penalty">
            <param argument="pen" type="text" value="" label="Norm used in the penalization" help=""/>
        </xml>
        <xml name="fit_intercept">
            <param argument="fit_intercept" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Should a constant (a.k.a. bias or intercept) be added to the decision function?" help=""/>
        </xml>
        <xml name="random_state">
            <param argument="random_state" type="integer" value="" optional="true" label="The seed of the pseudo random number generator to use when shuffling the data" help=""/>
        </xml>
        <xml name="max_iter">
            <param argument="max_iter" type="integer" value="100" label="Maximum number of iterations taken for the solvers to converge" help=""/>
        </xml>
        <xml name="multi_class">
            <param argument="multi_class" type="select" label="Multi class" help="">
                <option value="ovr">ovr: a binary problem is fit for each label</option>
                <option value="multinomial">multinomial: the multinomial loss fit across the entire probability distribution, even when the data is binary</option>
                <option value="auto">auto: selects ‘ovr’ if the data is binary and otherwise selects ‘multinomial’</option>
            </param>
        </xml>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
            python $script_file
    ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

sc.tl.rank_genes_groups(
    adata=adata,
    groupby='$groupby',
    use_raw=$use_raw,
#if $groups == 'rest'
    groups='$groups',
#end if
#if $ref.rest == 'rest'
    reference='$ref.rest',
#else
    reference='$ref.reference',
#end if
    n_genes=$n_genes,
    method='$method.method',
#if $method.method == 'logreg'
    solver='$method.solver.solver',
    #if $method.solver.solver == 'newton-cg'
    penalty='l2',
    fit_intercept=$method.solver.fit_intercept,
    max_iter=$method.solver.max_iter,
    multi_class='$method.solver.multi_class',
    #else if $method.solver.solver == 'lbfgs'
    penalty='l2',
    fit_intercept=$method.solver.fit_intercept,
    max_iter=$method.solver.max_iter,
    multi_class='$method.solver.multi_class',
    #else if $method.solver.solver == 'liblinear'
        #if $method.solver.penalty.penalty == 'l1'
    penalty='l1',
        #else if $method.solver.penalty.penalty == 'l2'
    penalty='l2',
    dual=$method.solver.penalty.dual,
        #else
    penalty='$method.solver.penalty.pen',
        #end if
    fit_intercept=$method.solver.intercept_scaling.fit_intercept,
        #if $method.solver.intercept_scaling.fit_intercept == 'True'
    intercept_scaling=$method.solver.intercept_scaling.intercept_scaling,
        #end if
        #if $method.solver.random_state
    random_state=$method.solver.random_state,
        #end if
    #else if $method.solver.solver == 'sag'
    penalty='l2',
    fit_intercept=$method.solver.fit_intercept,
        #if $method.solver.random_state
    random_state=$method.solver.random_state,
        #end if
    max_iter=$method.solver.max_iter,
    multi_class='$method.solver.multi_class',
    #else if $method.solver.solver == 'saga'
    #if $method.solver.penalty.penalty == 'l1'
    penalty='l1',
        #else if $method.solver.penalty.penalty == 'l2'
    penalty='l2',
        #else
    penalty='$method.solver.penalty.pen',
        #end if
    fit_intercept=$method.solver.fit_intercept,
    multi_class='$method.solver.multi_class',
    #end if
    tol=$method.tol,
    C=$method.c,
#end if
    only_positive=$only_positive)

@CMD_anndata_write_outputs@
adata.uns['rank_genes_groups']['names'].tofile('$names', sep = "\n")
adata.uns['rank_genes_groups']['scores'].tofile('$scores', sep = "\n")
]]>
        </configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <param argument="groupby" type="text" value="" label="The key of the observations grouping to consider" help=""/>
        <param argument="use_raw" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Use raw attribute of annotated matrix if present?" help=""/>
        <param argument="groups" type="text" value="" optional="true" label="Subset of groups to which comparison shall be restricted" help="e.g. ['g1', 'g2', 'g3']. If not passed, a ranking will be generated for all groups."/>
        <conditional name="ref">
            <param name="rest" type="select" label="Comparison">
                <option value="rest">Compare each group to the union of the rest of the group</option>
                <option value="group_id">Compare with respect to a specific group</option>
            </param>
            <when value="rest"/>
            <when value="group_id">
                <param argument="reference" type="text" value="" label="Group identifier with respect to which compare"/>
            </when>
        </conditional>
        <param argument="n_genes" type="integer" value="100" label="The number of genes that appear in the returned tables" help=""/>
        <conditional name="method">
            <param argument="method" type="select" label="Method">
                <option value="t-test">t-test</option>
                <option value="wilcoxon">Wilcoxon-Rank-Sum</option>
                <option value="t-test_overestim_var" selected="true">t-test with overestimate of variance of each group</option>
                <option value="logreg">Logistic regression</option>
            </param>
            <when value="t-test"/>
            <when value="wilcoxon"/>
            <when value="t-test_overestim_var"/>
            <when value="logreg">
                <conditional name="solver">
                    <param argument="solver" type="select" value="Algorithm to use in the optimization problem" help="For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones. For multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss; ‘liblinear’ is limited to one-versus-rest schemes. ‘newton-cg’, ‘lbfgs’ and ‘sag’ only handle L2 penalty, whereas ‘liblinear’ and ‘saga’ handle L1 penalty.">
                        <option value="newton-cg">newton-cg</option>
                        <option value="lbfgs">lbfgs</option>
                        <option value="liblinear">liblinear</option>
                        <option value="sag">sag</option>
                        <option value="saga">saga</option>
                    </param>
                    <when value="newton-cg">
                        <expand macro="fit_intercept"/>
                        <expand macro="max_iter"/>
                        <expand macro="multi_class"/>
                    </when>
                    <when value="lbfgs">
                        <expand macro="fit_intercept"/>
                        <expand macro="max_iter"/>
                        <expand macro="multi_class"/>
                    </when>
                    <when value="liblinear">
                        <conditional name="penalty">
                            <expand macro="penalty"/>
                            <when value="l1"/>
                            <when value="l2">
                                <param argument="dual" type="boolean" truevalue="True" falsevalue="False" checked="false" label="Dual (not primal) formulation?" help="Prefer primal when n_samples > n_features"/>
                            </when>
                            <when value="customized">
                                <expand macro="custom_penalty"/>
                            </when>
                        </conditional>
                        <conditional name="intercept_scaling">
                            <param argument="fit_intercept" type="select" label="Should a constant (a.k.a. bias or intercept) be added to the decision function?" help="">
                                <option value="True">Yes</option>
                                <option value="False">No</option>
                            </param>
                            <when value="True">
                                <param argument="intercept_scaling" type="float" value="1.0" label="Intercept scaling" help="x becomes [x, self.intercept_scaling], i.e. a 'synthetic' feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight."/>
                            </when>
                            <when value="False"/>
                        </conditional>
                        <expand macro="random_state"/>
                    </when>
                    <when value="sag">
                        <expand macro="fit_intercept"/>
                        <expand macro="random_state"/>
                        <expand macro="max_iter"/>
                        <expand macro="multi_class"/>
                    </when>
                    <when value="saga">
                        <conditional name="penalty">
                            <expand macro="penalty"/>
                            <when value="l1"/>
                            <when value="l2"/>
                            <when value="customized">
                                <expand macro="custom_penalty"/>
                            </when>
                        </conditional>
                        <expand macro="fit_intercept"/>
                        <expand macro="multi_class"/>
                    </when>
                </conditional>
                <param argument="tol" type="float" value="1e-4" label="Tolerance for stopping criteria" help=""/>
                <param argument="c" type="float" value="1.0" label="Inverse of regularization strength" help="It must be a positive float. Like in support vector machines, smaller values specify stronger regularization."/>
            </when>
        </conditional>
        <param argument="only_positive" type="boolean" truevalue="True" falsevalue="False" checked="true" label="Only consider positive differences?" help=""/>
        <expand macro="anndata_output_format"/>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
        <data name="names" format="txt" label="${tool.name} on ${on_string}: Gene names"/>
        <data name="scores" format="txt" label="${tool.name} on ${on_string}: Scores"/>
    </outputs>
    <tests>
        <test>
            <conditional name="input">
                <param name="format" value="h5ad" />
                <param name="adata" value="krumsiek11.h5ad" />
            </conditional>
            <param name="groupby" value="cell_type"/>
            <param name="use_raw" value="True"/>
            <conditional name="ref">
                <param name="rest" value="rest"/>
            </conditional>
            <param name="n_genes" value="100"/>
            <conditional name="method">
                <param name="method" value="t-test_overestim_var"/>
            </conditional>
            <param name="only_positive" value="True"/>
            <param name="anndata_output_format" value="h5ad" />
            <output name="anndata_out_h5ad" file="tl.rank_genes_groups.krumsiek11.h5ad" ftype="h5" compare="sim_size"/>
            <output name="names" file="tl.rank_genes_groups.gene_names.krumsiek11.txt"/>
            <output name="scores" file="tl.rank_genes_groups.scores.krumsiek11.txt"/>
        </test>
        <test>
            <conditional name="input">
                <param name="format" value="h5ad" />
                <param name="adata" value="pbmc68k_reduced.h5ad" />
            </conditional>
            <param name="groupby" value="louvain"/>
            <param name="use_raw" value="True"/>
            <conditional name="ref">
                <param name="rest" value="rest"/>
            </conditional>
            <param name="n_genes" value="100"/>
            <conditional name="method">
                <param name="method" value="logreg"/>
                <conditional name="solver">
                    <param name="solver" value="newton-cg"/>
                    <param name="fit_intercept" value="True"/>
                    <param name="max_iter" value="100"/>
                    <param name="multi_class" value="auto"/>
                </conditional>
                <param name="tol" value="1e-4"/>
                <param name="c" value="1.0"/>
            </conditional>
            <param name="only_positive" value="True"/>
            <param name="anndata_output_format" value="h5ad" />
            <output name="anndata_out_h5ad" file="tl.rank_genes_groups.pbmc68k_reduced_logreg_newton-cg.h5ad" ftype="h5" compare="sim_size"/>
            <output name="names" file="tl.rank_genes_groups.gene_names.pbmc68k_reduced_logreg_newton-cg.txt"/>
            <output name="scores" file="tl.rank_genes_groups.scores.pbmc68k_reduced_logreg_newton-cg.txt"/>
        </test>
        <test>
            <conditional name="input">
                <param name="format" value="h5ad" />
                <param name="adata" value="pbmc68k_reduced.h5ad" />
            </conditional>
            <param name="groupby" value="louvain"/>
            <param name="use_raw" value="True"/>
            <conditional name="ref">
                <param name="rest" value="rest"/>
            </conditional>
            <param name="n_genes" value="100"/>
            <conditional name="method">
                <param name="method" value="logreg"/>
                <conditional name="solver">
                    <param name="solver" value="liblinear"/>
                    <conditional name="penalty">
                        <param name="penalty" value="l2"/>
                        <param name="dual" value="False"/>
                        <conditional name="intercept_scaling">
                            <param name="fit_intercept" value="True"/>
                            <param name="intercept_scaling" value="1.0" />
                        </conditional>
                        <param name="random_state" value="1"/>
                    </conditional>
                </conditional>
                <param name="tol" value="1e-4"/>
                <param name="c" value="1.0"/>
            </conditional>
            <param name="only_positive" value="True"/>
            <param name="anndata_output_format" value="h5ad" />
            <output name="anndata_out_h5ad" file="tl.rank_genes_groups.pbmc68k_reduced_logreg_liblinear.h5ad" ftype="h5" compare="sim_size"/>
            <output name="names" file="tl.rank_genes_groups.gene_names.pbmc68k_reduced_logreg_liblinear.txt"/>
            <output name="scores" file="tl.rank_genes_groups.scores.pbmc68k_reduced_logreg_liblinear.txt"/>
        </test>
    </tests>
    <help><![CDATA[
Rank genes for characterizing groups.

Returns
-------
Gene names : Gene names ordered in column by group id and in rows according to scores

Scores : Score for each gene (rows) for each group (columns), same order as for the names

    ]]>
    </help>
    <expand macro="citations"/>
</tool>
