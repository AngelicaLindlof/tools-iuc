<tool id="tl.umap" name="tl.umap" version="1.3.1+galaxy1">
    <description>Embed the neighborhood graph using UMAP</description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements"/>
    <command detect_errors="exit_code"><![CDATA[
            python $script_file
        ]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[
@CMD_imports@
@CMD_read_inputs@

sc.tl.umap(
    adata=adata,
    min_dist=$min_dist,
    spread=$spread,
    n_components=$n_components,
    #if $maxiter
    maxiter=$maxiter,
    #end if
    alpha=$alpha,
    gamma=$gamma,
    negative_sample_rate=$negative_sample_rate,
    init_pos='$init_pos',
    random_state=$random_state,
    copy=False)

@CMD_anndata_write_outputs@
np.savetxt('$X_umap', adata.obsm['X_umap'], delimiter='\t')
]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="inputs_anndata"/>
        <param argument="min_dist" type="float" value="0.5" label="Effective minimum distance between embedded points" help="Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the `spread` value, which determines the scale at which embedded points will be spread out. The default of in the `umap-learn` package is 0.1."/>
        <param argument="spread" type="float" value="1.0" label="Effective scale of embedded points" help="In combination with `min_dist` this determines how clustered/clumped the embedded points are."/>
        <param argument="n_components" type="integer" value="2" label="Number of dimensions of the embedding" help=""/>
        <param argument="maxiter" type="integer" value="" optional="true" label="Number of iterations (epochs) of the optimization" help="Called `n_epochs` in the original UMAP."/>
        <param argument="alpha" type="float" value="1.0" label="Initial learning rate for the embedding optimization" help=""/>
        <param argument="gamma" type="float" value="1.0" label="Weighting applied to negative samples in low dimensional embedding optimization" help="Values higher than one will result in greater weight being given to negative samples."/>
        <param argument="negative_sample_rate" type="integer" value="5" label="The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding" help=""/>
        <param argument="init_pos" type="select" label="How to initialize the low dimensional embedding" help="Called `init` in the original UMAP">
            <option value="paga">Position from paga</option>
            <option value="spectral" selected="true">Spectral embedding of the graph</option>
            <option value="random">Initial embedding positions at random</option>
        </param>
        <param argument="random_state" type="integer" value="0" label="Random state" help="Change this to use different intial states for the optimization"/>
        <expand macro="anndata_output_format"/>
    </inputs>
    <outputs>
        <expand macro="anndata_outputs"/>
        <data name="X_umap" format="tabular" label="${tool.name} on ${on_string}: UMAP coordinates"/>
    </outputs>
    <tests>
        <test>
            <conditional name="input">
                <param name="format" value="h5ad" />
                <param name="adata" value="pp.neighbors.paul15_gauss_braycurtis.h5ad" />
            </conditional>
            <param name="min_dist" value="0.5"/>
            <param name="spread" value="1.0"/>
            <param name="n_components" value="2"/>
            <param name="maxiter" value="2"/>
            <param name="alpha" value="1.0"/>
            <param name="gamma" value="1.0"/>
            <param name="negative_sample_rate" value="5"/>
            <param name="init_pos" value="spectral"/>
            <param name="random_state" value="0"/>
            <param name="anndata_output_format" value="h5ad" />
            <output name="anndata_out_h5ad" file="tl.umap.neighbors.paul15_gauss_braycurtis.h5ad" ftype="h5" compare="sim_size"/>
            <output name="X_umap" file="tl.umap.neighbors.paul15_gauss_braycurtis.X_umap.tabular"/>
        </test>
    </tests>
    <help><![CDATA[
UMAP (Uniform Manifold Approximation and Projection) is a manifold learning
technique suitable for visualizing high-dimensional data. Besides tending to
be faster than tSNE, it optimizes the embedding such that it best reflects
the topology of the data, which we represent throughout Scanpy using a
neighborhood graph. tSNE, by contrast, optimizes the distribution of
nearest-neighbor distances in the embedding such that these best match the
distribution of distances in the high-dimensional space.  We use the
implementation of `umap-learn <https://github.com/lmcinnes/umap>`__
(McInnes et al, 2018). For a few comparisons of UMAP with tSNE, see this `preprint
<https://doi.org/10.1101/298430>`__.

Returns
-------
X_umap : UMAP coordinates of data.


More details on the `scanpy documentation
<https://scanpy.readthedocs.io/en/latest/api/scanpy.api.tl.umap.html#scanpy.api.tl.umap>`_
    ]]></help>
    <expand macro="citations"/>
</tool>
