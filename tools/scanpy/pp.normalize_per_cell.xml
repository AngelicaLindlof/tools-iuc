<tool id="pp.normalize_per_cell" name="pp.normalize_per_cell" version="1.3.1+galaxy1">
  <description>Normalize total counts per cell.</description>
  <macros>
    <import>macros.xml</import>
  </macros>
  <expand macro="requirements"/>
  <command detect_errors="exit_code"><![CDATA[
        python $script_file
    ]]></command>
  <configfiles>
    <configfile name="script_file"><![CDATA[
import scanpy.api as sc

@CMD_read_inputs

sc.pp.normalize_per_cell(
   data = '$adata',
   counts_per_cell_after = '$counts_per_cell_after',
   counts_per_cell = '$counts_per_cell',
   key_n_counts = '$key_n_counts',
   copy = '$copy',)

adata.write_loom($csv_output)
adata.write_csv($loom_output)

adata.write_loom($csv_output)
adata.write_csv($loom_output)
]]></configfile>
  </configfiles>
  <inputs>
    <expand macro="inputs_anndata"/>
    <param name="counts_per_cell_after" type="float" value="None" optional="true" label="counts_per_cell_after" help="    If `None`, after normalization, each cell has a total count equal    to the median of the *counts_per_cell* before normalization."/>
    <param name="counts_per_cell" type="np.array" value="None" optional="true" label="counts_per_cell" help="    Precomputed counts per cell."/>
    <param name="key_n_counts" type="str" value="'n_counts'" optional="true" label="key_n_counts" help="    Name of the field in `adata.obs` where the total counts per cell are    stored."/>
    <param name="copy" type="bool" value="False" optional="true" label="copy" help="    If an :class:`~anndata.AnnData` is passed, determines whether a copy    is returned."/>
    </inputs>
  <outputs>
    <data name="csv_output" type="data" format="csv" label="${tool.name} on ${on_string}: Annotated matrix (csv)"/>
    <data name="csv_output" type="data" format="csv" label="${tool.name} on ${on_string}: Annotated matrix (csv)"/>
    <data name="loom_output" type="data" format="loom" label="${tool.name} on ${on_string}: Annotated matrix (loom)"/>
    <data name="loom_output" type="data" format="loom" label="${tool.name} on ${on_string}: Annotated matrix (loom)"/>
    </outputs>
  <tests>
    <test>
      <param name="counts_per_cell_after" value=""/>
      <param name="counts_per_cell" value=""/>
      <param name="key_n_counts" value=""/>
      <param name="copy" value=""/>
      <output name="loom_output" file=""/>
      <output name="csv_output" file=""/>
      <output name="loom_output" file=""/>
      <output name="csv_output" file=""/>
      <output name="loom_output" file=""/>
      <output name="loom_output" file=""/>
    </test>
  </tests>
  <help><![CDATA[
        Normalize total counts per cell.

Normalize each cell by total counts over all genes, so that every cell has
the same total count after normalization.

Similar functions are used, for example, by Seurat [Satija15]_, Cell Ranger
[Zheng17]_ or SPRING [Weinreb17]_.

Parameters
----------
data : :class:`~anndata.AnnData`, `np.ndarray`, `sp.sparse`
    The (annotated) data matrix of shape `n_obs` Ã— `n_vars`. Rows correspond
    to cells and columns to genes.
counts_per_cell_after : `float` or `None`, optional (default: `None`)
    If `None`, after normalization, each cell has a total count equal
    to the median of the *counts_per_cell* before normalization.
counts_per_cell : `np.array`, optional (default: `None`)
    Precomputed counts per cell.
key_n_counts : `str`, optional (default: `'n_counts'`)
    Name of the field in `adata.obs` where the total counts per cell are
    stored.
copy : `bool`, optional (default: `False`)
    If an :class:`~anndata.AnnData` is passed, determines whether a copy
    is returned.

Returns
-------
Returns or updates `adata` with normalized version of the original
`adata.X`, depending on `copy`.

Examples
--------
>>> adata = AnnData(
>>>     data=np.array([[1, 0], [3, 0], [5, 6]]))
>>> print(adata.X.sum(axis=1))
[  1.   3.  11.]
>>> sc.pp.normalize_per_cell(adata)
>>> print(adata.obs)
>>> print(adata.X.sum(axis=1))
   n_counts
0       1.0
1       3.0
2      11.0
[ 3.  3.  3.]
>>> sc.pp.normalize_per_cell(adata, counts_per_cell_after=1,
>>>                          key_n_counts='n_counts2')
>>> print(adata.obs)
>>> print(adata.X.sum(axis=1))
   n_counts  n_counts2
0       1.0        3.0
1       3.0        3.0
2      11.0        3.0
[ 1.  1.  1.]
    ]]></help>
  <expand macro="citations"/>
</tool>
