<tool id="pp.neighbors" name="pp.neighbors" version="1.3.1+galaxy1">
  <description>Compute a neighborhood graph of observations [McInnes18]_.</description>
  <macros>
    <import>macros.xml</import>
  </macros>
  <expand macro="requirements"/>
  <command detect_errors="exit_code"><![CDATA[
        python $script_file
    ]]></command>
  <configfiles>
    <configfile name="script_file"><![CDATA[
import scanpy.api as sc



sc.pp.neighbors(
   adata = '$adata',
   n_neighbors = '$n_neighbors',
   n_pcs = '$n_pcs',
   use_rep = '$use_rep',
   knn = '$knn',
   random_state = '$random_state',
   method = '$method',
   metric = '$metric',
   metric_kwds = '$metric_kwds',
   copy = '$copy',)

adata.write_loom($csv_output)
adata.write_csv($loom_output)
]]></configfile>
  </configfiles>
  <inputs>
    <param name="adata" type="data" format="" value="" label="adata" help="    Annotated data matrix."/>
    <param name="n_neighbors" type="data" format="" value="" label="n_neighbors" help="    The size of local neighborhood (in terms of number of neighboring data    points) used for manifold approximation. Larger values result in more    global views of the manifold, while smaller values result in more local    data being preserved. In general values should be in the range 2 to 100.    If `knn` is `True`, number of nearest neighbors to be searched. If `knn`    is `False`, a Gaussian kernel width is set to the distance of the    `n_neighbors` neighbor."/>
    <param name="n_pcs" type="int" value="None" optional="true" label="n_pcs" help="    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`."/>
    <param name="use_rep" type="data" format="{`None`" value="None" optional="true" label="use_rep" help="    Use the indicated representation. If `None`, the representation is chosen    automatically: for `.n_vars` &lt; 50, `.X` is used, otherwise 'X_pca' is used.    If 'X_pca' is not present, it's computed with default parameters."/>
    <param name="knn" type="data" format="" value="" label="knn" help="    If `True`, use a hard threshold to restrict the number of neighbors to    `n_neighbors`, that is, consider a knn graph. Otherwise, use a Gaussian    Kernel to assign low weights to neighbors more distant than the    `n_neighbors` nearest neighbor."/>
    <param name="random_state" type="data" format="" value="" label="random_state" help="    A numpy random seed."/>
    <param name="method" type="data" format="{'umap'" value="'umap'" label="method" help="    Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_    with adaptive width [Haghverdi16]_) for computing connectivities."/>
    <param name="metric" type="data" format="" value="" label="metric" help="    A known metric’s name or a callable that returns a distance."/>
    <param name="metric_kwds" type="data" format="" value="" label="metric_kwds" help="    Options for the metric."/>
    <param name="copy" type="data" format="" value="" label="copy" help="    Return a copy instead of writing to adata."/>
    </inputs>
  <outputs>
    <data name="csv_output" type="data" format="csv" label="${tool.name} on ${on_string}: Annotated matrix (csv)"/>
    <data name="connectivities" type="data" format="sparse matrix " label="${tool.name} on ${on_string}: connectivities"/>
    <data name="distances" type="data" format="sparse matrix " label="${tool.name} on ${on_string}: distances"/>
    <data name="loom_output" type="data" format="loom" label="${tool.name} on ${on_string}: Annotated matrix (loom)"/>
    </outputs>
  <tests>
    <test>
      <param name="adata" value=""/>
      <param name="n_neighbors" value=""/>
      <param name="n_pcs" value=""/>
      <param name="use_rep" value=""/>
      <param name="knn" value=""/>
      <param name="random_state" value=""/>
      <param name="method" value=""/>
      <param name="metric" value=""/>
      <param name="metric_kwds" value=""/>
      <param name="copy" value=""/>
      <output name="loom_output" file=""/>
      <output name="csv_output" file=""/>
      <output name="connectivities" file=""/>
      <output name="distances" file=""/>
      <output name="loom_output" file=""/>
    </test>
  </tests>
  <help><![CDATA[
        Compute a neighborhood graph of observations [McInnes18]_.

The neighbor search efficiency of this heavily relies on UMAP [McInnes18]_,
which also provides a method for estimating connectivities of data points -
the connectivity of the manifold (`method=='umap'`). If `method=='diffmap'`,
connectivities are computed according to [Coifman05]_, in the adaption of
[Haghverdi16]_.

Parameters
----------
adata
    Annotated data matrix.
n_neighbors
    The size of local neighborhood (in terms of number of neighboring data
    points) used for manifold approximation. Larger values result in more
    global views of the manifold, while smaller values result in more local
    data being preserved. In general values should be in the range 2 to 100.
    If `knn` is `True`, number of nearest neighbors to be searched. If `knn`
    is `False`, a Gaussian kernel width is set to the distance of the
    `n_neighbors` neighbor.
n_pcs : `int` or `None`, optional (default: `None`)
    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.
use_rep : {`None`, 'X'} or any key for `.obsm`, optional (default: `None`)
    Use the indicated representation. If `None`, the representation is chosen
    automatically: for `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.
    If 'X_pca' is not present, it's computed with default parameters.
knn
    If `True`, use a hard threshold to restrict the number of neighbors to
    `n_neighbors`, that is, consider a knn graph. Otherwise, use a Gaussian
    Kernel to assign low weights to neighbors more distant than the
    `n_neighbors` nearest neighbor.
random_state
    A numpy random seed.
method : {'umap', 'gauss', `None`}  (default: `'umap'`)
    Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_
    with adaptive width [Haghverdi16]_) for computing connectivities.
metric
    A known metric’s name or a callable that returns a distance.
metric_kwds
    Options for the metric.
copy
    Return a copy instead of writing to adata.

Returns
-------
Depending on `copy`, updates or returns `adata` with the following:
connectivities : sparse matrix (`.uns['neighbors']`, dtype `float32`)
    Weighted adjacency matrix of the neighborhood graph of data
    points. Weights should be interpreted as connectivities.
distances : sparse matrix (`.uns['neighbors']`, dtype `float32`)
    Instead of decaying weights, this stores distances for each pair of
    neighbors.
    ]]></help>
  <expand macro="citations"/>
</tool>
